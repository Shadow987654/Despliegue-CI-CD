# ================================================
# GITHUB ACTIONS CI/CD PIPELINE
# ================================================
# Pipeline para aplicaciÃ³n de microservicios
# Arquitectura: API, Web, DB, Notifications, Nginx
# Registry: Azure Container Registry (ACR)
# ================================================

name: CI/CD Pipeline - Azure Deploy

# -------------------- TRIGGERS --------------------
on:
  push:
    branches:
      - main                              # Trigger automÃ¡tico en push a main
  workflow_dispatch:                      # Permite ejecuciÃ³n manual desde GitHub UI

# -------------------- VARIABLES --------------------
env:
  # Azure Container Registry
  REGISTRY_URL: miproyectoacr.azurecr.io  # URL del Azure Container Registry
  REGISTRY_USER: ${{ secrets.ACR_USERNAME }}     # Usuario ACR (configurar en GitHub Secrets)
  REGISTRY_PASSWORD: ${{ secrets.ACR_PASSWORD }} # Password ACR (configurar en GitHub Secrets)
  
  # Servidor de producciÃ³n
  VM_HOST: ${{ secrets.VM_HOST }}        # IP del servidor (ej: 172.16.9.31)
  VM_USERNAME: ${{ secrets.VM_USERNAME }}        # Usuario SSH (ej: docker-alumnos01)
  VM_SSH_KEY: ${{ secrets.VM_SSH_KEY }}  # Clave privada SSH
  
  # Nombres de imÃ¡genes Docker (ACR)
  API_IMAGE: miproyectoacr.azurecr.io/todos-api
  WEB_IMAGE: miproyectoacr.azurecr.io/todos-web
  DB_IMAGE: miproyectoacr.azurecr.io/todos-db
  NOTIFICATIONS_IMAGE: miproyectoacr.azurecr.io/todos-notifications
  NGINX_IMAGE: miproyectoacr.azurecr.io/todos-nginx
  
  # Tag de versiÃ³n (SHA corto del commit)
  IMAGE_TAG: ${{ github.sha }}
  
  # Variables de configuraciÃ³n
  DOCKER_NETWORK: app-network
  PATH_SERVER_USR: /home/azureuser/app
  
  # Variables de aplicaciÃ³n (no sensibles)
  MYSQL_DATABASE: todos_db
  MYSQL_USER: todos_user
  SMTP_SERVER: smtp.gmail.com
  SMTP_PORT: "587"
  EMAIL_FROM: noreply@todos.com

# -------------------- JOBS --------------------
jobs:
  
  # ========================================
  # JOB 1: BUILD & PUSH - API
  # ========================================
  build-api:
    name: ðŸ”¨ Build API Image
    runs-on: ubuntu-latest
    # Solo ejecutar si hubo cambios en api/ o docker-compose.yml
    if: |
      contains(github.event.head_commit.modified, 'api/') || 
      contains(github.event.head_commit.added, 'api/') ||
      contains(github.event.head_commit.modified, 'docker-compose.yml') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: ðŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      # Login a Azure Container Registry
      - name: ðŸ” Login to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}
      
      # Configurar Docker Buildx para builds eficientes
      - name: ðŸ› ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # Build y push de imagen API
      - name: ðŸ³ Build and Push API Image
        uses: docker/build-push-action@v5
        with:
          context: ./api                  # Contexto de build (carpeta api/)
          file: ./api/Dockerfile          # Dockerfile a usar
          push: true                      # Push automÃ¡tico a registry
          tags: |
            ${{ env.API_IMAGE }}:${{ github.sha }}
            ${{ env.API_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.API_IMAGE }}:latest  # Cache desde latest
          cache-to: type=inline           # Guardar cache en la imagen
      
      - name: âœ… API Image Built Successfully
        run: |
          echo "âœ“ API image built and pushed:"
          echo "  - ${{ env.API_IMAGE }}:${{ github.sha }}"
          echo "  - ${{ env.API_IMAGE }}:latest"

  # ========================================
  # JOB 2: BUILD & PUSH - WEB
  # ========================================
  build-web:
    name: ðŸ”¨ Build Web Image
    runs-on: ubuntu-latest
    if: |
      contains(github.event.head_commit.modified, 'web/') || 
      contains(github.event.head_commit.added, 'web/') ||
      contains(github.event.head_commit.modified, 'docker-compose.yml') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: ðŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      - name: ðŸ” Login to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}
      
      - name: ðŸ› ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: ðŸ³ Build and Push Web Image
        uses: docker/build-push-action@v5
        with:
          context: ./web
          file: ./web/Dockerfile
          push: true
          tags: |
            ${{ env.WEB_IMAGE }}:${{ github.sha }}
            ${{ env.WEB_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.WEB_IMAGE }}:latest
          cache-to: type=inline
      
      - name: âœ… Web Image Built Successfully
        run: |
          echo "âœ“ Web image built and pushed:"
          echo "  - ${{ env.WEB_IMAGE }}:${{ github.sha }}"
          echo "  - ${{ env.WEB_IMAGE }}:latest"

  # ========================================
  # JOB 3: BUILD & PUSH - DB
  # ========================================
  build-db:
    name: ðŸ”¨ Build Database Image
    runs-on: ubuntu-latest
    if: |
      contains(github.event.head_commit.modified, 'db/') || 
      contains(github.event.head_commit.added, 'db/') ||
      contains(github.event.head_commit.modified, 'docker-compose.yml') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: ðŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      - name: ðŸ” Login to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}
      
      - name: ðŸ› ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: ðŸ³ Build and Push DB Image
        uses: docker/build-push-action@v5
        with:
          context: ./db
          file: ./db/Dockerfile
          push: true
          tags: |
            ${{ env.DB_IMAGE }}:${{ github.sha }}
            ${{ env.DB_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.DB_IMAGE }}:latest
          cache-to: type=inline
      
      - name: âœ… DB Image Built Successfully
        run: |
          echo "âœ“ DB image built and pushed:"
          echo "  - ${{ env.DB_IMAGE }}:${{ github.sha }}"
          echo "  - ${{ env.DB_IMAGE }}:latest"

  # ========================================
  # JOB 4: BUILD & PUSH - NOTIFICATIONS
  # ========================================
  build-notifications:
    name: ðŸ”¨ Build Notifications Image
    runs-on: ubuntu-latest
    if: |
      contains(github.event.head_commit.modified, 'notifications/') || 
      contains(github.event.head_commit.added, 'notifications/') ||
      contains(github.event.head_commit.modified, 'docker-compose.yml') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: ðŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      - name: ðŸ” Login to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}
      
      - name: ðŸ› ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: ðŸ³ Build and Push Notifications Image
        uses: docker/build-push-action@v5
        with:
          context: ./notifications
          file: ./notifications/Dockerfile
          push: true
          tags: |
            ${{ env.NOTIFICATIONS_IMAGE }}:${{ github.sha }}
            ${{ env.NOTIFICATIONS_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.NOTIFICATIONS_IMAGE }}:latest
          cache-to: type=inline
      
      - name: âœ… Notifications Image Built Successfully
        run: |
          echo "âœ“ Notifications image built and pushed:"
          echo "  - ${{ env.NOTIFICATIONS_IMAGE }}:${{ github.sha }}"
          echo "  - ${{ env.NOTIFICATIONS_IMAGE }}:latest"

  # ========================================
  # JOB 5: BUILD & PUSH - NGINX
  # ========================================
  build-nginx:
    name: ðŸ”¨ Build Nginx Image
    runs-on: ubuntu-latest
    # Nginx siempre se builda (es el gateway)
    
    steps:
      - name: ðŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      - name: ðŸ” Login to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}
      
      - name: ðŸ› ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: ðŸ³ Build and Push Nginx Image
        uses: docker/build-push-action@v5
        with:
          context: ./nginx
          file: ./nginx/Dockerfile
          push: true
          tags: |
            ${{ env.NGINX_IMAGE }}:${{ github.sha }}
            ${{ env.NGINX_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.NGINX_IMAGE }}:latest
          cache-to: type=inline
      
      - name: âœ… Nginx Image Built Successfully
        run: |
          echo "âœ“ Nginx image built and pushed:"
          echo "  - ${{ env.NGINX_IMAGE }}:${{ github.sha }}"
          echo "  - ${{ env.NGINX_IMAGE }}:latest"

  # ========================================
  # JOB 6: DEPLOY TO PRODUCTION
  # ========================================
  deploy-production:
    name: ðŸš€ Deploy to Production
    runs-on: ubuntu-latest
    # Esperar a que todos los builds terminen
    needs: [build-api, build-web, build-db, build-notifications, build-nginx]
    # Solo si todos los builds tuvieron Ã©xito O si no se ejecutaron (optional)
    if: |
      always() &&
      (needs.build-api.result == 'success' || needs.build-api.result == 'skipped') &&
      (needs.build-web.result == 'success' || needs.build-web.result == 'skipped') &&
      (needs.build-db.result == 'success' || needs.build-db.result == 'skipped') &&
      (needs.build-notifications.result == 'success' || needs.build-notifications.result == 'skipped') &&
      (needs.build-nginx.result == 'success' || needs.build-nginx.result == 'skipped')
    
    steps:
      - name: ðŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4
      
      # Crear archivos .env y secrets localmente antes de transferir
      - name: ðŸ“ Crear archivos .env
        run: |
          # API .env
          cat > api/.env << EOF
          DB_HOST=db
          DB_PORT=3306
          DB_NAME=${{ env.MYSQL_DATABASE }}
          DB_USER=${{ env.MYSQL_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          FLASK_ENV=production
          FLASK_DEBUG=false
          FLASK_APP=app.py
          SECRET_KEY=${{ secrets.FLASK_SECRET_KEY }}
          HOST=0.0.0.0
          PORT=5000
          LOG_LEVEL=DEBUG
          LOG_FORMAT=json
          CORS_ORIGINS=http://localhost:3000,http://localhost:80,http://localhost
          CORS_ALLOW_CREDENTIALS=true
          NOTIFICATIONS_SERVICE_URL=http://notifications:8001
          EOF
          
          # DB .env
          cat > db/.env << EOF
          MYSQL_DATABASE=${{ env.MYSQL_DATABASE }}
          MYSQL_USER=${{ env.MYSQL_USER }}
          MYSQL_ROOT_PASSWORD=${{ secrets.DB_ROOT_PASSWORD }}
          MYSQL_PASSWORD=${{ secrets.DB_PASSWORD }}
          MYSQL_TCP_PORT=3306
          MYSQL_BIND_ADDRESS=0.0.0.0
          MYSQL_INNODB_BUFFER_POOL_SIZE=256M
          MYSQL_MAX_CONNECTIONS=100
          MYSQL_CHARACTER_SET_SERVER=utf8mb4
          MYSQL_COLLATION_SERVER=utf8mb4_unicode_ci
          MYSQL_DEFAULT_TIME_ZONE=America/Argentina/Buenos_Aires
          EOF
          
          # Notifications .env
          cat > notifications/.env << EOF
          SMTP_USERNAME=${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
          SMTP_SERVER=${{ env.SMTP_SERVER }}
          SMTP_PORT=${{ env.SMTP_PORT }}
          HOST=0.0.0.0
          PORT=8001
          EOF
          
          # Web .env
          cat > web/.env << EOF
          REACT_APP_API_URL=http://localhost:5000
          REACT_APP_ENV=production
          EOF
          
          # Nginx .env
          cat > nginx/.env << EOF
          NGINX_HOST=localhost
          NGINX_PORT=80
          NGINX_SSL_PORT=443
          API_UPSTREAM=api:5000
          WEB_UPSTREAM=web:3000
          NOTIFICATIONS_UPSTREAM=notifications:8001
          EOF
          
          echo "âœ“ Archivos .env creados"
      
      - name: ðŸ” Crear archivos de secrets
        run: |
          mkdir -p secrets
          echo "${{ secrets.DB_PASSWORD }}" > secrets/db_password.txt
          echo "${{ secrets.DB_ROOT_PASSWORD }}" > secrets/db_root_password.txt
          echo "${{ secrets.FLASK_SECRET_KEY }}" > secrets/flask_secret_key.txt
          echo "${{ secrets.SMTP_USERNAME }}" > secrets/smtp_username.txt
          echo "${{ secrets.SMTP_PASSWORD }}" > secrets/smtp_password.txt
          chmod 644 secrets/*.txt
          echo "âœ“ Archivos de secrets creados"
      
      # Actualizar docker-compose.yml con imÃ¡genes de ACR
      - name: ðŸ”„ Actualizar docker-compose.yml con imÃ¡genes de ACR
        run: |
          # Backup del original
          cp docker-compose.yml docker-compose.yml.bak
          
          # Reemplazar registry en todas las imÃ¡genes
          sed -i 's|registry-alumnos.labsis.frc.utn.edu.ar:8443/|miproyectoacr.azurecr.io/|g' docker-compose.yml
          
          echo "âœ“ docker-compose.yml actualizado con ACR registry"
          echo "ImÃ¡genes actualizadas:"
          grep "image: " docker-compose.yml
      
      # Deploy usando SSH con appleboy/ssh-action
      - name: ðŸš€ Deploy via SSH to Production Server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          port: 22
          script: |
            echo "================================================"
            echo "ðŸš€ INICIANDO DEPLOY EN SERVIDOR DE PRODUCCIÃ“N"
            echo "================================================"
            
            # Crear directorio de proyecto si no existe
            mkdir -p ${{ env.PATH_SERVER_USR }}/trabajo-practico-grupo-01
            cd /home/azureuser/app
            
            echo "ðŸ“‚ Directorio actual: $(pwd)"
            
            # Limpiar deployment anterior (mantener volÃºmenes)
            echo "ðŸ§¹ Limpiando deployment anterior..."
            docker compose down --remove-orphans 2>/dev/null || true
            docker volume rm trabajo-practico-grupo-01_nginx_ssl 2>/dev/null || true
            
            # Login a Azure Container Registry
            echo "ðŸ” Login to Azure Container Registry..."
            echo "${{ secrets.ACR_PASSWORD }}" | docker login miproyectoacr.azurecr.io \
              -u "${{ secrets.ACR_USERNAME }}" --password-stdin
            
            # Pull de todas las imÃ¡genes desde ACR
            echo "ðŸ“¥ Pulling images from ACR..."
            docker pull miproyectoacr.azurecr.io/todos-api:latest
            docker pull miproyectoacr.azurecr.io/todos-web:latest
            docker pull miproyectoacr.azurecr.io/todos-db:latest
            docker pull miproyectoacr.azurecr.io/todos-notifications:latest
            docker pull miproyectoacr.azurecr.io/todos-nginx:latest
            
            echo "âœ“ Todas las imÃ¡genes descargadas desde ACR"
      
      # Transferir archivos necesarios al servidor
      - name: ðŸ“¤ Transfer files to Production Server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          port: 22
          source: "docker-compose.yml,api/.env,db/.env,notifications/.env,web/.env,nginx/.env,secrets/*"
          target: "${{ env.PATH_SERVER_USR }}/trabajo-practico-grupo-01"
          strip_components: 0
      
      # Iniciar servicios con docker compose
      - name: ðŸ³ Start Docker Compose Services
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          port: 22
          command_timeout: 10m            # Timeout extendido para generaciÃ³n de SSL
          script: |
            cd ${{ env.PATH_SERVER_USR }}/trabajo-practico-grupo-01
            
            echo "ðŸš€ Iniciando servicios con docker compose..."
            docker compose up -d
            
            echo "ðŸ“Š Estado de contenedores:"
            docker compose ps
            
            echo "â³ Esperando a que MySQL estÃ© listo..."
            MAX_WAIT=60
            ELAPSED=0
            until docker exec todos-db mysqladmin ping -h localhost --silent 2>/dev/null; do
              if [ $ELAPSED -ge $MAX_WAIT ]; then
                echo "âŒ ERROR: MySQL no respondiÃ³ despuÃ©s de ${MAX_WAIT} segundos"
                docker logs todos-db --tail=50
                exit 1
              fi
              if [ $(($ELAPSED % 5)) -eq 0 ]; then
                echo "  Esperando MySQL... (${ELAPSED}s/${MAX_WAIT}s)"
              fi
              sleep 2
              ELAPSED=$((ELAPSED+2))
            done
            echo "âœ“ MySQL estÃ¡ listo"
            
            # Reiniciar API para conexiÃ³n limpia
            echo "ðŸ”„ Reiniciando API..."
            docker compose restart api
            sleep 5
            
            # Esperar a que Nginx genere certificados SSL (puede tomar tiempo)
            echo "â³ Esperando generaciÃ³n de certificados SSL y DH params..."
            MAX_WAIT=300
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              if docker logs todos-nginx 2>&1 | grep -q "âœ… DH params generados exitosamente"; then
                echo "âœ… Nginx completÃ³ la generaciÃ³n de SSL en ${ELAPSED} segundos"
                break
              fi
              
              if docker logs todos-nginx 2>&1 | grep -q "nginx entered RUNNING state"; then
                echo "âœ… Nginx ya estÃ¡ en estado RUNNING"
                break
              fi
              
              if [ $(($ELAPSED % 15)) -eq 0 ] && [ $ELAPSED -gt 0 ]; then
                echo "  â³ Generando SSL... (${ELAPSED}s/${MAX_WAIT}s)"
              fi
              
              sleep 3
              ELAPSED=$((ELAPSED + 3))
            done
            
            echo "ðŸ“Š Estado final de contenedores:"
            docker compose ps
            
            echo "ðŸ¥ Health Check del gateway HTTPS..."
            MAX_ATTEMPTS=20
            ATTEMPT=0
            until curl -s -k -f https://${{ secrets.VM_HOST }}:60143 > /dev/null 2>&1; do
              ATTEMPT=$((ATTEMPT+1))
              if [ "$ATTEMPT" -ge "$MAX_ATTEMPTS" ]; then
                echo "âŒ ERROR: Timeout esperando respuesta HTTPS"
                docker logs todos-nginx --tail=50
                exit 1
              fi
              if [ $(($ATTEMPT % 5)) -eq 0 ]; then
                echo "  Intento $ATTEMPT/$MAX_ATTEMPTS..."
              fi
              sleep 3
            done
            
            echo "âœ… Gateway HTTPS respondiÃ³ correctamente"
            
            # Probar endpoints
            echo "ðŸ§ª Probando endpoints..."
            curl -s -k -I https://${{ secrets.VM_HOST }}:60143 | head -n 5
            curl -s -k https://${{ secrets.VM_HOST }}:60143/api/ || true
            curl -s -k https://${{ secrets.VM_HOST }}:60143/api/todos || true
            
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "âœ… DESPLIEGUE COMPLETADO EXITOSAMENTE"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "URLs de acceso:"
            echo "  ðŸŒ Frontend: https://${{ secrets.VM_HOST }}:60143"
            echo "  ðŸ”§ API Root: https://${{ secrets.VM_HOST }}:60143/api/"
            echo "  ðŸ“ Tareas:   https://${{ secrets.VM_HOST }}:60143/api/todos"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      
      # Cleanup de imÃ¡genes antiguas (mantener solo latest y current SHA)
      - name: ðŸ§¹ Cleanup Old Docker Images
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          port: 22
          script: |
            echo "ðŸ§¹ Limpiando imÃ¡genes Docker antiguas..."
            
            # Eliminar imÃ¡genes dangling (sin tag)
            echo "Eliminando imÃ¡genes dangling..."
            docker image prune -f
            
            # Eliminar imÃ¡genes antiguas del proyecto (mantener latest y SHA actual)
            echo "Limpiando imÃ¡genes antiguas de ACR..."
            
            # Lista de servicios
            SERVICES="todos-api todos-web todos-db todos-notifications todos-nginx"
            
            for SERVICE in $SERVICES; do
              echo "Procesando $SERVICE..."
              
              # Obtener todas las imÃ¡genes del servicio excepto latest y SHA actual
              OLD_IMAGES=$(docker images "miproyectoacr.azurecr.io/$SERVICE" \
                --format "{{.Repository}}:{{.Tag}}" | \
                grep -v ":latest" | \
                grep -v ":${{ github.sha }}" || true)
              
              if [ -n "$OLD_IMAGES" ]; then
                echo "  Eliminando imÃ¡genes antiguas de $SERVICE:"
                echo "$OLD_IMAGES" | while read IMAGE; do
                  echo "    - $IMAGE"
                  docker rmi "$IMAGE" 2>/dev/null || true
                done
              else
                echo "  âœ“ No hay imÃ¡genes antiguas de $SERVICE"
              fi
            done
            
            # Mostrar espacio liberado
            echo "ðŸ“Š Uso de disco despuÃ©s de cleanup:"
            docker system df
            
            echo "âœ“ Cleanup completado"

  # ========================================
  # JOB 7: VERIFY DEPLOYMENT
  # ========================================
  verify-deployment:
    name: âœ… Verify Production Deployment
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: success()
    
    steps:
      - name: ðŸ” Verificar estado de servicios
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          port: 22
          script: |
            cd ${{ env.PATH_SERVER_USR }}/trabajo-practico-grupo-01
            
            echo "================================================"
            echo "ðŸ” VERIFICACIÃ“N DE DEPLOYMENT"
            echo "================================================"
            
            echo "ðŸ“Š Estado de contenedores:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo ""
            echo "ðŸ’» Uso de recursos:"
            docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
            
            echo ""
            echo "ðŸ¥ Health checks:"
            docker inspect --format='{{.Name}} - {{.State.Health.Status}}' $(docker ps -q) 2>/dev/null || echo "No health checks configured"
            
            echo ""
            echo "ðŸ” InformaciÃ³n de certificados SSL:"
            docker exec todos-nginx sh -c '
              if [ -f "/etc/nginx/ssl/server.crt" ]; then
                openssl x509 -in /etc/nginx/ssl/server.crt -noout -subject -dates
                echo "âœ“ Certificado SSL encontrado"
                ls -lh /etc/nginx/ssl/dhparam.pem 2>/dev/null && echo "âœ“ DH params encontrado" || echo "âš  DH params no encontrado"
              else
                echo "âš  No se encontrÃ³ certificado SSL"
              fi
            ' || echo "âš  No se pudo verificar certificados"
            
            echo ""
            echo "ðŸ“¦ ImÃ¡genes en uso:"
            docker compose images
            
            echo ""
            echo "ðŸŒ Logs recientes de Nginx:"
            docker logs todos-nginx --tail=20 2>&1
            
            echo "================================================"
            echo "âœ… VERIFICACIÃ“N COMPLETADA"
            echo "================================================"
